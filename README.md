# Coroutine

English Readme is [here](README-EN.md).

这是一种为内存极度受限的系统设计的轻量级无栈协程框架。

## 特色

- **无栈**：这是最核心的特点，传统线程每个都有独立栈空间，而Coroutine复用单一栈，仅通过状态变量记录执行位置，内存占用极低（通常仅需几个字节的状态变量）；
- **轻量级**：无线程栈开销，创建/切换成本几乎可以忽略，适合资源紧缺的场景；
- **伪阻塞**：支持在C函数内实现阻塞逻辑，但阻塞的本质是状态暂停，仅记录当前执行位置，不保存任务其他状态（如局部变量值等），等待事件触发后，继续从阻塞点执行函数；
- **灵活适配**：可配合RTOS使用，也可直接运行在裸机的事件驱动框架上；

## 原理
Coroutine的核心是通过**宏定义**和**状态变量**实现任务的暂停和恢复。

用pt_t类型的结构体记录线程当前执行的 “状态点”（本质是一个整数）；
通过PT_BEGIN()、PT_WAIT_UNTIL()、PT_END()等宏，将线性代码拆分为 “状态片段”；
当遇到 “阻塞条件”（如PT_WAIT_UNTIL(pt, condition)），线程会记录当前状态并退出函数；
事件触发后（condition 满足），函数再次被调用时，从记录的状态点继续执行，而非从头开始。
*阻塞时程序会从当前函数返回，任务让出栈空间，事件触发后任务恢复到阻塞位置继续执行，因为栈空间已经让出，所以不保证函数内的局部变量还会保持原来的值；
